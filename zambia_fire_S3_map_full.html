<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>leaflet</title>
<style type="text/css">@layer htmltools {
.html-fill-container {
display: flex;
flex-direction: column;

min-height: 0;
min-width: 0;
}
.html-fill-container > .html-fill-item {

flex: 1 1 auto;
min-height: 0;
min-width: 0;
}
.html-fill-container > :not(.html-fill-item) {

flex: 0 0 auto;
}
}
</style>
<script>(function() {
  // If window.HTMLWidgets is already defined, then use it; otherwise create a
  // new object. This allows preceding code to set options that affect the
  // initialization process (though none currently exist).
  window.HTMLWidgets = window.HTMLWidgets || {};

  // See if we're running in a viewer pane. If not, we're in a web browser.
  var viewerMode = window.HTMLWidgets.viewerMode =
      /\bviewer_pane=1\b/.test(window.location);

  // See if we're running in Shiny mode. If not, it's a static document.
  // Note that static widgets can appear in both Shiny and static modes, but
  // obviously, Shiny widgets can only appear in Shiny apps/documents.
  var shinyMode = window.HTMLWidgets.shinyMode =
      typeof(Shiny) !== "undefined" && !!Shiny.setInputValue;

  // Called by widget bindings to register a new widget instance.
  //
  // The binding object should have a name and a find() method. It can also
  // have initialize() and renderValue() methods.
  window.HTMLWidgets.widget = function(binding) {

    // Some things are done differently in Shiny vs. static mode.
    if (shinyMode) {
      // Register the binding with Shiny
      Shiny.inputBindings.register(new ShinyInputBinding(binding),
        "htmlwidgets." + binding.name);
    }

    // Augment the binding with a few methods that are common to all bindings.
    binding = extend(binding, {
      // Get the "scope" of a widget. This is the nearest element with a
      // data-htmlwidget-scope attribute. If none, return document.
      getScope: function(el) {
        var scope = $(el).closest("[data-htmlwidget-scope]");
        if (scope.length > 0)
          return scope[0];
        else
          return document;
      },

      // Find all widget instances in a scope.
      findAll: function(scope) {
        return $(scope).find("div.html-widget[data-for='" + binding.name + "']");
      },

      // A function that provides a standard way of wiring up widget events
      // (e.g. click) to Shiny. Currently, the only event that's supported
      // is "click", and it's only respected if the widget element has a
      // data-click-id attribute.
      proxyEvents: function(el, data) {
        var clickId = $(el).attr("data-click-id");
        if (clickId) {
          $(el).on("click.htmlwidgets", function(e) {
            Shiny.setInputValue(clickId, {
              ".nonce": Math.random()  // Nonce so input always fires
            });
          });
        }
      }
    });

    // Find all instances of this widget on the page and attempt to bind them.
    //
    // It's not necessary to wait for document.ready. The widget framework
    // will wait for any script tags within the widget's HTML to finish
    // loading before binding.
    findAndBind(binding);

    // Return the binding object.
    return binding;
  };

  // Store the Shiny input binding class, in case a user wants to derive from it.
  window.HTMLWidgets.ShinyInputBinding = ShinyInputBinding;


  // Shiny input binding
  // ------------------------------------------------------------------
  // This is a custom Shiny input binding that is used for htmlwidgets.
  // It's a simple wrapper around the binding object that is passed to
  // HTMLWidgets.widget().
  function ShinyInputBinding(binding) {
    this.binding = binding;
  }

  // An input binding must have a find method that returns a jQuery object
  // of the elements that are to be bound.
  ShinyInputBinding.prototype.find = function(scope) {
    // Get the scope of the widget and use that to find all instances
    return this.binding.findAll(scope);
  };

  // It must also have a getValue method that returns the value of the
  // input.
  ShinyInputBinding.prototype.getValue = function(el) {
    var data = $(el).data("htmlwidget-data");
    if (!data)
      return null;
    return data.value;
  };

  // It must also have a setValue method that sets the value of the
  // input.
  ShinyInputBinding.prototype.setValue = function(el, value) {
    this.renderValue(el, value);
  };

  // It must also have a subscribe method that allows Shiny to listen
  // for events that may change the value of the input.
  ShinyInputBinding.prototype.subscribe = function(el, callback) {
    $(el).on("change.htmlwidgets", function(e) {
      callback();
    });
  };

  // It must also have an unsubscribe method that allows Shiny to
  // stop listening for events that may change the value of the input.
  ShinyInputBinding.prototype.unsubscribe = function(el) {
    $(el).off(".htmlwidgets");
  };

  // It must also have a getType method that returns the type of the
  // input.
  ShinyInputBinding.prototype.getType = function(el) {
    // It's hard to know what the type should be, so we'll just return
    // "Object". In the future, we may be able to get more specific.
    return "Object";
  };

  // Receive messages from the server.
  ShinyInputBinding.prototype.receiveMessage = function(el, data) {
    var instance = $(el).data("htmlwidget-instance");
    if (instance && instance.receiveMessage) {
      instance.receiveMessage(data);
    }
  };

  // Get the rate policy for this input.
  ShinyInputBinding.prototype.getRatePolicy = function() {
    return {
      policy: "direct"
    };
  };

  // The following methods are not part of the input binding interface,
  // but are used by the input binding to render the widget. They are
  // implemented here as wrappers around the binding object's methods.

  // Get the ID of the input.
  ShinyInputBinding.prototype.getId = function(el) {
    return this.binding.getId(el);
  };

  // Render the widget.
  ShinyInputBinding.prototype.renderValue = function(el, data) {
    this.binding.renderValue(el, data, this);
  };


  // Internal functions
  // ------------------------------------------------------------------

  // Find all widget bindings in a scope and bind them.
  function findAndBind(binding) {
    // Wait for DOM content to be loaded
    if (document.readyState === "complete" ||
        document.readyState === "interactive") {
      bindImmediately(binding);
    } else {
      document.addEventListener("DOMContentLoaded", function() {
        bindImmediately(binding);
      });
    }
  }

  function bindImmediately(binding) {
    var allWidgets = binding.findAll(document);

    // Track the number of widgets that have been bound.
    var boundWidgets = 0;

    // A function that will be called when a widget is bound.
    var onBound = function() {
      boundWidgets++;

      // When all widgets are bound, trigger a custom event.
      if (boundWidgets === allWidgets.length) {
        $(document).trigger("htmlwidgets:bound");
      }
    };

    // For each widget, wait for its script tags to be loaded, then bind it.
    allWidgets.each(function() {
      var el = this;
      var $el = $(el);

      // The "data-for" attribute indicates which binding this element is
      // for. This is used to distinguish between different types of widgets.
      var bindingName = $el.attr("data-for");
      if (!bindingName)
        return;

      // The "data-htmlwidget-state" attribute is used to track the state of
      // the widget. It can be "unbound", "binding", or "bound".
      var state = $el.attr("data-htmlwidget-state");
      if (state === "unbound") {
        // If the widget is unbound, then we need to bind it.
        // Set the state to "binding" to prevent it from being bound again.
        $el.attr("data-htmlwidget-state", "binding");
        waitForScriptsAndAssets(el, function() {
          // When the scripts and assets are loaded, bind the widget.
          bindWidget(el, binding);
          // Set the state to "bound".
          $el.attr("data-htmlwidget-state", "bound");
          onBound();
        });
      }
    });
  }

  // Wait for all scripts and assets to be loaded, then execute a callback.
  function waitForScriptsAndAssets(el, callback) {
    var $el = $(el);

    // Find all script and link tags within the element.
    var $dependencies = $el.find("script, link");
    var dependencies = $dependencies.get();

    // A function that will be called when a dependency is loaded.
    var loaded = 0;
    var onDependencyLoad = function() {
      loaded++;
      if (loaded === dependencies.length) {
        callback();
      }
    };

    // If there are no dependencies, then execute the callback immediately.
    if (dependencies.length === 0) {
      callback();
      return;
    }

    // For each dependency, add a load event listener.
    dependencies.forEach(function(dep) {
      var $dep = $(dep);

      // The "data-htmlwidget-dependency-state" attribute is used to track the
      // state of the dependency. It can be "unloaded", "loading", or "loaded".
      var state = $dep.attr("data-htmlwidget-dependency-state");

      if (state === "loaded") {
        onDependencyLoad();
        return;
      }

      // If the dependency is a script, then add a load event listener to it.
      if (dep.tagName === "SCRIPT") {
        // If the script is already loaded, then call the callback immediately.
        // This can happen if the script is loaded from the cache.
        if (dep.readyState === "complete" || dep.readyState === "loaded") {
          onDependencyLoad();
          return;
        }
      }

      // If the dependency is a link, then we need to check if it's a
      // stylesheet. If it is, then we need to wait for it to be loaded.
      if (dep.tagName === "LINK" && dep.rel === "stylesheet") {
        // There's no reliable way to know when a stylesheet has been
        // loaded. We'll just assume it's loaded after a short delay.
        // This is a hack, but it's the best we can do.
        // The proper way to do this is to use a library like
        // https://github.com/filamentgroup/loadCSS
        setTimeout(onDependencyLoad, 20);
        return;
      }

      // Add a load event listener to the dependency.
      $dep.on("load", onDependencyLoad);

      // Add an error event listener to the dependency.
      $dep.on("error", onDependencyLoad);
    });
  }


  // Bind a widget.
  function bindWidget(el, binding) {
    var $el = $(el);

    // Get the widget's data from the <script> tag.
    var dataStr = $el.find("script[type='application/json']").text();
    var data = JSON.parse(dataStr);

    // If the widget has a "data" property, then it's a static widget.
    if (data.hasOwnProperty("x")) {
      // Augment the data with the element, so the binding can access it.
      data.el = el;

      // Store the data on the element.
      $el.data("htmlwidget-data", data);

      // Call the binding's initialize method.
      var instance = binding.initialize(el, data.x.width, data.x.height);
      $el.data("htmlwidget-instance", instance);

      // If the widget has a resize method, then wire it up.
      if (instance.resize) {
        // Get the fill container.
        var fillContainer = $(el).parent(".html-fill-container");
        if (fillContainer.length > 0) {
          // If the widget is in a fill container, then resize it when the
          // container is resized.
          fillContainer.on("resize", function(e) {
            if (e.target === fillContainer[0]) {
              var newWidth = fillContainer.width();
              var newHeight = fillContainer.height();
              instance.resize(newWidth, newHeight);
            }
          });

          // Also resize it when the window is resized.
          $(window).on("resize", function(e) {
            var newWidth = fillContainer.width();
            var newHeight = fillContainer.height();
            instance.resize(newWidth, newHeight);
          });

          // Resize it one time to initialize the size.
          var initialWidth = fillContainer.width();
          var initialHeight = fillContainer.height();
          instance.resize(initialWidth, initialHeight);

        } else {
          // If the widget is not in a fill container, then resize it when
          // the window is resized.
          $(window).on("resize", function(e) {
            var newWidth = $el.width();
            var newHeight = $el.height();
            instance.resize(newWidth, newHeight);
          });
        }
      }

      // Call the binding's renderValue method.
      binding.renderValue(el, data.x, instance);

      // Proxy events from the widget to Shiny.
      binding.proxyEvents(el, data);
    }
  }


  // A simplified version of jQuery.extend
  function extend(a, b) {
    for (var i in b) {
      if (b.hasOwnProperty(i)) {
        a[i] = b[i];
      }
    }
    return a;
  }

})();</script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rstudio/leaflet@2.0.3/inst/htmlwidgets/lib/leaflet-binding/leaflet.css" />
<script src="https://cdn.jsdelivr.net/gh/rstudio/leaflet@2.0.3/inst/htmlwidgets/lib/leaflet-binding/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/gh/rstudio/htmlwidgets@v1.5.4/inst/www/htmlwidgets.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.sync@0.2.4/dist/L.Map.Sync.css" />
<script src="https://cdn.jsdelivr.net/npm/leaflet.sync@0.2.4/dist/L.Map.Sync.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@1.3.1/src/easy-button.css" />
<script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@1.3.1/src/easy-button.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-providers/1.9.0/leaflet-providers.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/rstudio/leaflet.providers@main/inst/htmlwidgets/lib/leaflet-providers-binding/leaflet-providers-binding.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-minimap/3.6.1/Control.MiniMap.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-minimap/3.6.1/Control.MiniMap.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/nerik/leaflet-scalemeters@0.0.4/L.Control.Scale.css" />
<script src="https://cdn.jsdelivr.net/gh/nerik/leaflet-scalemeters@0.0.4/L.Control.Scale.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.2/leaflet.draw.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.2/leaflet.draw.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/r-spatial/mapview@2.0.3/inst/htmlwidgets/lib/mapview/mapview.css" />
<script src="https://cdn.jsdelivr.net/gh/r-spatial/mapview@2.0.3/inst/htmlwidgets/lib/mapview/mapview.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/r-spatial/leafem@0.1.3/inst/htmlwidgets/lib/plainview/plainview.css" />
<script src="https://cdn.jsdelivr.net/gh/r-spatial/leafem@0.1.3/inst/htmlwidgets/lib/plainview/plainview.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/r-spatial/leafem@0.1.3/inst/htmlwidgets/lib/leafem/leafem.css" />
<script src="https://cdn.jsdelivr.net/gh/r-spatial/leafem@0.1.3/inst/htmlwidgets/lib/leafem/leafem.js"></script>

<!-- This style block moves the zoom controls to the bottom left -->
<style>
  .leaflet-top.leaflet-left {
    top: auto;
    bottom: 10px;
  }
</style>
</head>
<body style="background-color:white;">
<div class="html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget_map" style="width:100%;height:480px;"></div>
<script type="application/json" data-for="htmlwidget_map">
{"x":{"options":{"crs":{"crsClass":"L.CRS.EPSG3857","code":null,"proj4def":null,"projectedBounds":null,"options":{}}},"calls":[{"method":"addProviderTiles","args":["Esri.WorldImagery",null,null,{"errorTileUrl":"","noWrap":false,"detectRetina":false}]},{"method":"addRasterImage","args":[["https://github.com/mccarthy-m-g/zambia_firms/blob/main/data/raster/S3_2024203_radiance.tif?raw=true"],{"alpha":1,"layerId":"S3_2024203_radiance.tif","attribution":"","group":"Sentinel-3 NRT (VIIRS)","project":true,"resample":true,"opacity":1}]},{"method":"addRasterImage","args":[["https://github.com/mccarthy-m-g/zambia_firms/blob/main/data/raster/S3_2024203_frp.tif?raw=true"],{"alpha":1,"layerId":"S3_2024203_frp.tif","attribution":"","group":"Sentinel-3 NRT (VIIRS)","project":true,"resample":true,"opacity":1}]},{"method":"addRasterImage","args":[["https://github.com/mccarthy-m-g/zambia_firms/blob/main/data/raster/S3_2024203_frp_1km.tif?raw=true"],{"alpha":1,"layerId":"S3_2024203_frp_1km.tif","attribution":"","group":"Sentinel-3 NRT (VIIRS)","project":true,"resample":true,"opacity":1}]},{"method":"addLayersControl","args":[["Sentinel-3 NRT (VIIRS)"],[],{"collapsed":true,"position":"topright"}]},{"method":"addMiniMap","args":[null,"Esri.WorldStreetMap","topright",150,150,19,19,-5,4,false,false,true,false,true,{"color":"#ff7800","weight":1,"clickable":false},{"color":"#000000","weight":1,"clickable":false,"opacity":0,"fillOpacity":0},{"hideText":"Hide MiniMap","showText":"Show MiniMap"},[]]},{"method":"addScaleBar","args":[{"maxWidth":100,"metric":true,"imperial":true,"updateWhenIdle":true,"position":"bottomright"}]},{"method":"addHomeButton","args":["<img src='https://github.com/mccarthy-m-g/zambia_firms/blob/main/data/raster/zambia_vector.png?raw=true' style='width:30px; height:30px;'>",-13.5,27.8,6,"Zoom to Zambia","topleft"]},{"method":"addDrawToolbar","args":[{"targetGroup":"draw","position":"topleft","polylineOptions":false,"polygonOptions":false,"circleOptions":false,"rectangleOptions":{"shapeOptions":{"clickable":true}},"markerOptions":false,"circleMarkerOptions":false,"editOptions":{"edit":false,"remove":true},"singleFeature":false}]},{"method":"addPlainView","args":[]},{"method":"addMouseCoordinates","args":[{"position":"bottomleft","epsg":null,"proj4string":null,"transform.fun":null,"lng.format":"%s", "lat.format":"%s", "lng.col.name":"Lon", "lat.col.name":"Lat"}]},{"method":"addLogo","args":["https://github.com/mccarthy-m-g/zambia_firms/blob/main/data/raster/github_logo.png?raw=true","https://github.com/mccarthy-m-g/zambia_firms/",100,50,"bottomleft"]},{"method":"hideGroup","args":["Sentinel-3 NRT (VIIRS)"]}],"setView":[[-13.5,27.8],6,[]],"limits":{"lat":[-13.5,-13.5],"lng":[27.8,27.8]}},"evals":[],"jsHooks":[]}</script>
</body>
</html>
